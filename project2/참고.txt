x_x_0_xxx_0_xx_xxx_0_x_000_000_10001_0x_xxx_xx_0_xxxxxxxx_11  // 0x05:  sltu execution
x_x_0_xxx_0_xx_xxx_0_x_000_000_01110_00_xxx_xx_0_xxxxxxxx_11  // 0x06:  srl execution
x_x_0_xxx_0_xx_xxx_0_1_000_011_00100_0x_xxx_xx_0_xxxxxxxx_11  // 0x07:  addi execution
x_x_0_xxx_0_00_000_1_x_xxx_xxx_xxxxx_xx_xxx_xx_0_xxxxxxxx_00  // 0x08:  addi completion
1_x_1_010_0_xx_xxx_0_x_xxx_xxx_xxxxx_xx_xxx_xx_0_xxxxxxxx_00  // 0x09:  sh memory access
1_1_0_111_0_xx_xxx_0_x_xxx_xxx_xxxxx_xx_xxx_xx_0_xxxxxxxx_11  // 0x0a:  lb memory access
x_x_0_xxx_0_00_001_1_x_xxx_xxx_xxxxx_xx_xxx_xx_0_xxxxxxxx_00  // 0x0b:  lb write-back

and, nor sltu, srl r-type completion(write-back) 똑같음
addi는 목적지 레지스터만 다름

addi, sh, lb execution 같음

1. srl execution에서 ALUsrcB로 000을 사용, shamt값을 그대로 쓰는거니까 seu(sign extension unit)을 지날 필요가 없음
2. bne, bgez에서 EXTmode = x, 이전 state에서 branch address 미리 계산하기에 extend 필요 없음
3. bgez에서 PCwrite = 1
4 x_x_0_xxx_0_11_100_1_x_000_010_00100_0x_000_00_1_xxxxxxxx_00  // 0x13:  jalr completion
이유 : PCsrc는
From ALU output
From ALUOut Register
From Jump Address
From Current PC
네개밖에없음.  근데 $rs를 jump pc로 사용해야 함. 
따라서 alu에서 $rs+0을 연산하고 그 결과값을 pc에 쓴다.

bne, bgez 명령어를 구현하면서 처음에는 EXTmode를 어떻게 설정해야 할지 혼란스러웠다. 싱글 사이클 CPU에서는 항상 즉시값을 확장하는 방식이었기 때문에, 멀티 사이클에서도 동일하게 확장해야 한다고 생각했다.

해결 방향:
멀티 사이클 구조에서는 DECODE 단계(state 1)에서 이미 분기 주소 계산을 수행하고, 그 결과를 ALUOut Register에 저장한다. 따라서 이후 분기 판단 단계에서는 즉시값 확장이 불필요하므로, 해당 단계에서는 EXTmode = x로 설정해도 문제가 없다는 것을 이해하고 적용하였다.